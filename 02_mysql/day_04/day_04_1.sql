-- 7장. SQL 고급 : 274~294P
-- JOIN QUERY  
-- 1. INNER JOIN (내부 조인) : 274~283P
SELECT FIRST_NAME 사원명, E.DEPARTMENT_ID 부서코드, DEPARTMENT_NAME 부서명 
FROM EMPLOYEES E INNER JOIN DEPARTMENTS D  -- 테이블 ALIAS 선언 사용 권고
ON E.DEPARTMENT_ID = D.DEPARTMENT_ID; -- JOIN

-- 부서 이름 별 100,000 이상인 급여 총합
SELECT D.DEPARTMENT_NAME '부서 이름', SUM(E.SALARY) '급여 총합'
FROM EMPLOYEES E INNER JOIN DEPARTMENTS D
ON E.DEPARTMENT_ID = D.DEPARTMENT_ID
GROUP BY D.DEPARTMENT_NAME
HAVING SUM(E.SALARY) >= 100000
ORDER BY '부서 이름';

-- 세 개의 테이블 JOIN
-- FROM A INNER JOIN B ON A.ID=B.ID
-- B INNER JOIN C ON B.C.ID=B.ID
-- 위와 같이 INNER JOIN ON 을 늘리면 계속해서 연결할 수 있다.

# 세 개의 테이블 JOIN - 예제1
-- 사원명, 근무 도시명, 국가명 조회하려고 한다.
DESC EMPLOYEES;
DESC DEPARTMENTS;
DESC LOCATIONS;
DESC COUNTRIES;
-- EMPLOYEES와 LOCATIONS에는 조인하려고 하는 공통된 컬럼이 없다.
-- 하지만 EMPLOYEES와 DEPARTMENTS는 조인할 수 있고,
-- DEPARTMENTS와 L0CATIONS는 조인이 가능하다.
-- LOCATIONS와 COUNTRIES도 조인 가능하다.
-- 따라서 네 테이블을 조인해야 한다.
SELECT E.FIRST_NAME, L.CITY, C.COUNTRY_NAME
FROM EMPLOYEES E 
INNER JOIN DEPARTMENTS D ON E.DEPARTMENT_ID=D.DEPARTMENT_ID
INNER JOIN LOCATIONS L ON D.LOCATION_ID=L.LOCATION_ID -- DAPARTMENTS와 LOCATION 조인
INNER JOIN COUNTRIES C ON L.COUNTRY_ID=C.COUNTRY_ID; -- LOCATIONS와 COUNTRIES 조인

# 세 개의 테이블 JOIN - 예제2
-- 사원명, 부서명, 근무 도시명, 국가명 조회
-- 50, 80, 100 부서만, 급여 5000 이상 사원만 조회
SELECT D.DEPARTMENT_ID, E.SALARY, E.FIRST_NAME 사원명, D.DEPARTMENT_NAME 부서명, L.CITY 도시명, C.COUNTRY_NAME 국가명
FROM EMPLOYEES E
INNER JOIN DEPARTMENTS D ON E.DEPARTMENT_ID=D.DEPARTMENT_ID 
INNER JOIN LOCATIONS L ON D.LOCATION_ID=L.LOCATION_ID 
INNER JOIN COUNTRIES C ON L.COUNTRY_ID=C.COUNTRY_ID
WHERE D.DEPARTMENT_ID IN(50, 80, 100) AND E.SALARY >= 5000;


-- 2. OUTER JOIN (외부 조인) : 284~288P

SELECT COUNT(*) FROM EMPLOYEES; -- 107개 (NULL값이 하나 있다는 이야기)
SELECT COUNT(DEPARTMENT_ID) FROM EMPLOYEES; -- 106개 : 컬럼 NOT NULL 개수
-- NULL 데이터 1개를 찾아보자
SELECT FIRST_NAME, DEPARTMENT_ID
FROM EMPLOYEES
WHERE DEPARTMENT_ID IS NULL; -- Kimberely의 DEPARTMENT_ID가 NULL

SELECT FIRST_NAME 사원명, E.DEPARTMENT_ID 부서코드, DEPARTMENT_NAME 부서명 
FROM EMPLOYEES E INNER JOIN DEPARTMENTS D  
ON E.DEPARTMENT_ID = D.DEPARTMENT_ID; -- 106개 : NULL = NULL 동일 데이터가 없다.
-- 즉, E.DEPARTMENT_ID에는 NULL 데이터가 하나 있는데, DEPARTMENT_ID에는 NULL이 없다.

-- INNER JOIN : JOIN 2개 테이블에 모두 존재하고, 조건이 일치하는 데이터만 합침
-- OUTER JOIN : JOIN 2개 테이블에 모두 존재하고, 조건이 일치하지 않아도 데이터만 합침

-- 2-1. LEFT OUTER JOIN 
-- JOIN 조건을 만족하지 않아도 왼쪽 테이블(EMPLOYEES)에 있는 모든 데이터 다 가지고 온다.
-- 즉, Kimberely의 NULL 값도 가지고 온다.
-- 아래는 사원들의 부서코드, 부서명을 조회하되 부서 소속되지 않는 사원은 부서코드 '-', 부서명 '소속부서없음' 출력한다.
SELECT FIRST_NAME 사원명, IFNULL(E.DEPARTMENT_ID, '-') 부서코드, IFNULL(DEPARTMENT_NAME, '소속부서없음') 부서명 
FROM EMPLOYEES E LEFT OUTER JOIN DEPARTMENTS D  
ON E.DEPARTMENT_ID=D.DEPARTMENT_ID
ORDER BY FIRST_NAME; -- 107개 

-- 2-2. RIGHT OUTER JOIN
-- 아래는 각 부서명, 근무하는 사람이 있는 부서명을 조회하되 해당 부서에 근무하는 사원이 없는 부서명도 조회
SELECT DISTINCT IFNULL(FIRST_NAME, '부서원 없음') 사원명, D.DEPARTMENT_ID 부서코드, DEPARTMENT_NAME 부서명 
FROM EMPLOYEES E RIGHT OUTER JOIN DEPARTMENTS D  
ON E.DEPARTMENT_ID = D.DEPARTMENT_ID;  -- 부서원이 없는 부서코드는 120번 이상이라는 것을 알 수 있다.
SELECT * FROM EMPLOYEES WHERE DEPARTMENT_ID >= 120; -- 즉, 데이터 없다.

-- 3. CROSS JOIN : 288~290P : 모든 데이터 조인을 다 하기 때문에 올바른 조인이 아니다. 그저 대용량 데이터를 만들기 위해 만들어 놓은 것이다.

-- 4. SELF JOIN (자체 조인) : 290~292P : 자기 자신과 자기 자신이 조인한다.
-- 사원 본인의 사번은 EMPLOYEE_ID, 사원의 상사 사번은 MANAGER_ID에 있다.
-- 두 데이터는 모두 EMPLOYEES 테이블에 존재하고, MANAGER_ID 사번은 모두 EMPLOYEE_ID에 있다.
-- 사원 본인의 상사 이름을 알아보자.
SELECT EMPLOYEE_ID, FIRST_NAME, MANAGER_ID
FROM EMPLOYEES
WHERE FIRST_NAME LIKE 'K%'; -- Kimberely의 EMPLOYEE_ID=178, MANAGER_ID=149

SELECT EMPLOYEE_ID, FIRST_NAME
FROM EMPLOYEES
WHERE EMPLOYEE_ID = 149; -- 상사의 이름은 Eleni 라는 것을 알 수 있다.

-- 이제 두 번 조회하는 것이 아니라 JOIN을 사용한 한 번의 조회로 알아보자.

-- 예제 1) 사원명 상사명 (상사 없는 사원 제외)
SELECT ME.FIRST_NAME 사원명, MANAGER.FIRST_NAME 상사명 
FROM EMPLOYEES ME INNER JOIN EMPLOYEES MANAGER -- 자기자신을 조회하기 때문에 테이블 ALIAS 필수이다.
ON ME.MANAGER_ID = MANAGER.EMPLOYEE_ID
ORDER BY ME.FIRST_NAME;  -- 106 (INNER JOIN 은 그냥 JOIN이라고 써도 된다.)

SELECT EMPLOYEE_ID, FIRST_NAME FROM EMPLOYEES WHERE MANAGER_ID IS NULL; -- Steven 한 명 있다. 

-- 예제 2) 사원명 상사명 (상사 없는 사원 포함)
SELECT ME.FIRST_NAME 사원명, MANAGER.FIRST_NAME 상사명 
FROM EMPLOYEES ME LEFT OUTER JOIN EMPLOYEES MANAGER 
ON ME.MANAGER_ID = MANAGER.EMPLOYEE_ID; -- 107 (그냥 LEFT JOIN이라고만 써도 된다.)

-- 예제 3) 사원명 상사명 (부하직원 없는 상사 포함)
SELECT IFNULL(ME.FIRST_NAME, '신입사원') 사원명, MANAGER.FIRST_NAME 상사명 
FROM EMPLOYEES ME RIGHT OUTER JOIN EMPLOYEES MANAGER 
ON ME.MANAGER_ID = MANAGER.EMPLOYEE_ID; -- 195


-- 5. UNION, UNION ALL, NOT IN, IN : 292~294P

-- EMP_DEPT_50 이라는 새로운 테이블을 만든다. : EMPLOYEES 테이블 내 50번 부서원만 저장한 테이블 (11개 컬럼)
CREATE TABLE EMP_DEPT_50 (SELECT * FROM EMPLOYEES WHERE DEPARTMENT_ID=50);

-- EMP_JOB_MAN 이라는 새로운 테이블을 만든다. : EMPLOYEES 테이블 내 직종코드 MANAGER만 저장한 테이블 (11개 컬럼)
CREATE TABLE EMP_JOB_MAN (SELECT * FROM EMPLOYEES WHERE JOB_ID LIKE '%MAN%');

-- 두 테이블 조회해보기
SELECT * FROM EMP_DEPT_50;
SELECT * FROM EMP_JOB_MAN;

-- 50번 부서이거나 MANAGER 직종인 사람에게 재난지원금을 주려고 한다.
-- 만약 50번 부서이면서 MANAGER 직종인 사람에게는 한 번만 준다. (중복 X)
-- 재난지원금 받을 대상을 조회해보자.

-- 5-1. UNION (합집합 : A, B 테이블 중 1개만 포함해도 조회하고, 양쪽에 모두 포함되었다면 1개만) : 두 쿼리의 결과를 행으로 합치는 것
SELECT EMPLOYEE_ID, FIRST_NAME, JOB_ID, DEPARTMENT_ID
FROM EMP_DEPT_50 
UNION 
SELECT EMPLOYEE_ID, FIRST_NAME, JOB_ID, DEPARTMENT_ID
FROM EMP_JOB_MAN;

-- 5-2. UNION ALL : UNION과 달리 중복되면 중복되는대로 보여줘!
SELECT EMPLOYEE_ID, FIRST_NAME, JOB_ID, DEPARTMENT_ID
FROM EMP_DEPT_50 
UNION ALL
SELECT EMPLOYEE_ID, FIRST_NAME, JOB_ID, DEPARTMENT_ID
FROM EMP_JOB_MAN;

-- 5-3-1. IN, NOT IN을 설명하기 위해 알아보는 SUBQUERY
-- JOIN QUERY : 2개 이상의 테이블에 나누어졌을 때 컬럼을 합친다.
-- UNION : 2개 이상의 테이블에 나누어졌을 때 레코드를 합친다.
-- SUBQUERY : 다른 쿼리 안에 포함되는 SELECT (ex) 119, 122줄)
-- 지금은 SELECT문 안에 SELECT문이 포함되는 SUBQUERY를 살펴보자.

-- EMPLOYEES 테이블에서 KELLY와 같은 부서 사원의 이름, 부서코드 조회
SELECT FIRST_NAME 이름, DEPARTMENT_ID 부서코드
FROM EMPLOYEES
WHERE DEPARTMENT_ID=(SELECT DEPARTMENT_ID FROM EMPLOYEES WHERE FIRST_NAME='Kelly'); -- SUBQUERY는 괄호 안에! / 반드시 왼쪽과 오른쪽의 컬럼의 개수와 타입이 일치해야 한다.

-- EMPLOYEES 테이블에서 KELLY와 같은 부서 사원이면서 같은 직종인 사원의 이름 부서코드 조회 : 컬럼이 여러 개일 때
SELECT FIRST_NAME 이름, DEPARTMENT_ID 부서코드, JOB_ID 직종코드
FROM EMPLOYEES
WHERE (JOB_ID, DEPARTMENT_ID)=(SELECT JOB_ID, DEPARTMENT_ID FROM EMPLOYEES WHERE FIRST_NAME='Kelly')
AND FIRST_NAME != 'Kelly'; -- Kelly는 한 명이지만, 만약 Peter처럼 여러명이 있다면 조회 어렵다.


-- 5-3-2. IN : 일치하는 것을 보여준다.
-- 5-3-3. NOT IN : 제외하고 보여준다.
-- Peter와 같은 부서원 조회
SELECT FIRST_NAME 이름, DEPARTMENT_ID 부서코드, JOB_ID 직종코드
FROM EMPLOYEES
WHERE DEPARTMENT_ID NOT IN(SELECT DEPARTMENT_ID FROM EMPLOYEES WHERE FIRST_NAME='Peter'); -- 80, 50 제외

SELECT JOB_ID, DEPARTMENT_ID FROM EMPLOYEES WHERE DEPARTMENT_ID = 50;
SELECT JOB_ID, DEPARTMENT_ID FROM EMPLOYEES WHERE DEPARTMENT_ID IN (50, 80);

-- SUBQUERY 사용을 해서 WHERE 절 조건을 쓸 때, 단일행 SUBQUERY '=', 다중행 SUBQUERY 'IN'을 사용한다.
-- 만약 아래의 집계함수처럼 값이 1개만 나오는 경우는 '='를 사용할 수는 있겠다.
SELECT FIRST_NAME 이름, DEPARTMENT_ID 근무부서코드
FROM EMPLOYEES
WHERE SALARY = (SELECT TRUNCATE(AVG(SALARY),-2) FROM EMPLOYEES);