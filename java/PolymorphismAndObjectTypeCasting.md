# 다형성과 객체 형 변환 



1.  [다형성(Polymorphism)이란?](##다형성(polymorphism)이란?)
2. [객체 형 변환 (Object Type Casting)](##객체-형-변환-(object-Type-Casting))
   - [자동 형 변환 (Promotion)](###자동-형-변환-(promotion))
   - [강제 형 변환 (Casting)](###강제-형-변환-(casting)) 

<br>

<br>

---

## 다형성(Polymorphism)이란?

<mark>**같은 타입이지만 실행 결과가 다양한 객체를 이용할 수 있는 성질**</mark>

<br>

### <span style="color:Cornflowerblue">" 객체를  부품화 "</span>

> 자동차는 타이어 타입이고, 한국 타이어와 금호 타이어 모두 사용 가능하다. 
>
> 하지만 각 타이어의 성능은 다르게 나온다.

:red_car: 

자동차를 설계 시, **타이어 인터페이스 타입**을 적용한다면

**한국 타이어 객체**, **금호 타이어 객체** 어떤 것이든 상관없이 장착 가능!

<br>

### <span style="color:Cornflowerblue">" 형변환을 통해 "</span>

자바는 다형성을 위해 

부모 클래스 또는 인터페이스의 형변환을 허용한다.

`부모 타입`에 모든 `자식 객체` 대입  ok

`인터페이스 타입`에 모든 `구현 객체`가 대입 ok

<br>

<br>

---

## 객체 형 변환 (Object Type Casting)

형 변환은 데이터 타입을 다른 데이터 타입으로 변환하는 행위이다. 타입 변환이라고도 한다. 

객체 형 변환은 **상속 관계**에 있는 클래스 사이에서 발생한다.

<br>

### 자동 형 변환 (Promotion)

자식은 부모의 특징과 기능을 상속받기 때문에 부모와 동일하게 취급될 수 있다는 개념이다.

`자식 클래스`는 `부모 클래스`으로 자동 형 변환이 가능하다!

<br>

아래의 코드에서 HankookTire와 KumhoTire는 Tire를 상속했기 때문에 Tire 변수에 대입할 수 있다.

```java
public class Car {
    Tire t1 = new HankookTire();
    Tire t2 = new KumhoTire();
}
```

<br>

:mushroom:  바로 위의 부모가 아니더라도 상속 계층에서 **상위 타입**이라면 자동 형 변환이 일어날 수 있다.

<br>

:mushroom: **자동 형 변환이 일어난 후에는 ?**

> 부모 타입으로 자동 형 변환이 된 이후에는 부모 클래스에 선언된 필드와 메소드만 접근할 수 있다.
>
> <mark>**단, 예외적으로 메소드가 자식 클래스에서 Overriding 되었다면 자식 클래스의 메소드가 대신 호출된다!**</mark>

<br>

:mushroom: **왜 위의 예외 상황이 발생할까 ?**

> 다형성(Polymorphism)과 관련이 있다. 

<br>

:mushroom: **굳이 부모 타입으로 변환해서 사용하는 이유는 ?**

> 다형성을 구현하는 기술적 방법 때문이다. 
>
> 필드의 타입은 변함이 없지만, 실행 도중에 어떤 객체를 필드로 저장하느냐에 따라 실행 결과가 달라질 수 있는데 이것이 <mark>**필드의 다형성**</mark>이다.
>
> <br>
>
> `자동차 클래스` 설계 시, `타이어 객체`는 언제든지 성능이 좋은 `다른 타이어 객체`로 교체할 수 있어야 한다.
>
> `새로 교체되는 타이어 객체`는 `기존 타이어 객체`와 사용 방법과 동일하지만 실행 결과는 더 우수해야 한다.
>
> 이것을 프로그램으로 구현하기 위해서 **상속**과 **오버라이딩**, **형 변환**을 이용하는 것이다. 
>
> <br>
>
> 부모 클래스를 상속하는 자식 클래스는 부모가 가지고 있는 필드와 메소드를 가지고 있으니 사용 방법이 동일하고, 자식 클래스는 부모의 메소드를 오버라이딩(재정의)해서 메소드의 실행 내용을 변경함으로써 더 우수한 실행 결과가 나오게 할 수 있다. 그리고 자식 타입을 부모 타입으로 변환할 수 있다.

<br>

<br>

<mark>**하나의 배열로 객체를 관리하자!**</mark>

동일한 타입의 값들은 배열로 관리하는 것이 유리하다. 

인덱스로 표현되므로 대입이나 제어문에서 활용하기 매우 쉽기 때문이다.

<br>

<mark>**매개변수의 다형성**</mark>

매개 변수의 타입이 클래스일 경우, 해당 클래스의 객체뿐만 아니라 자식 객체까지도 매개값으로 사용할 수 있다!

매개값으로 어떤 자식 객체가 제공되느냐에 따라 메소드의 실행 결과는 다양해질 수 있다. 

이것이 매개변수의 다형성이다.

<br>

<br>

---

### 강제 형 변환 (Casting)

`부모 타입`을 `자식 타입`으로 변환하는 것을 말한다.

하지만 자식 타입이 부모 타입으로 변환한 상태(자동 형 변환)일 경우에만 가능하다.

즉, `자식 타입`이 `부모 타입`으로 자동 변환하고 나서 다시 `자식 타입`으로 변환할 때 강제 형 변환을 사용한다.

<br>

:mushroom: **부모 변수가 참조하는 객체가 부모 객체인지 자식 객체인지 확인하는 방법은 ?**

> <mark>**객체 타입 확인**</mark> 
>
> instanceof 연산자를 사용해 확인할 수 있다.
>
> 메소드 내에서 강제 형 변환이 필요할 경우에는 반드시 매개값이 어떤 객체인지 instanceof 연산자로 확인하고 안전하게 강제 형 변환을 해야 한다.

```java
boolean result = 좌항(객체) instanceof 우항(타입)
```

좌항(객체)이 우항(타입)의 인스턴스이면, 즉 우항의 타입으로 객체가 생성되었다면 true

그렇지 않으면 false