# SOLID (객체 지향 설계)

컴퓨터 프로그래밍에서 **SOLID**란 로버트 마틴이 2000년대 초반에 명명한 객체 지향 프로그래밍 및 설계의 다섯 가지 기본 원칙을 마이클 페더스가 두문자어 기억술로 소개한 것이다. 프로그래머가 시간이 지나도 유지 보수와 확장이 쉬운 시스템을 만들고자 할 때 이 원칙들을 함께 적용할 수 있다. SOLID 원칙들은 소프트웨어 작업에서 프로그래머가 소스 코드가 읽기 쉽고 확장하기 쉽게 될 때까지 소프트웨어 소스 코드를 리팩터링하여 코드 냄새를 제거하기 위해 적용할 수 있는 지침이다. 이 원칙들은 애자일 소프트웨어 개발과 적응적 소프트웨어 개발의 전반적 전략의 일부다.

- **단일 책임 원칙 (Single responsibility principle, SRP)**
    - 한 클래스는 하나의 책임만 가져야 한다.
- **개방-폐쇄 원칙 (Open/closed principle)**
    - 소프트웨어 요소는 확장에는 열려 있으나 변경에는 닫혀 있어야 한다.
- **리스코프 치환 원칙 (Liskov substitution principle, LSP)**
    - 프로그램의 객체는 프로그램의 정확성을 깨뜨리지 않으면서 하위 타입의 인스턴스로 바꿀 수 있어야 한다. 계약에 의한 설계를 참고하라.
- **인터페이스 분리 원칙 (Interface segregation principle, ISP)**
    - 특정 클라이언트를 위한 인터페이스 여러 개가 범용 인터페이스 하나보다 낫다.
- **의존관계 역전 원칙 (Dependency inversion principle, DIP)**
    - 프로그래머는 추상화에 의존해야지, 구체화에 의존하면 안된다. 의존성 주입은 이 원칙을 따르는 방법 중 하나이다.

---

# 디자인 패턴 : Iterator [예제]

- Student.java

```java
public class Student {
    private int studentNo;
    private String name;
    private String department;
    private String address;

    public Student(int studentNo, String name) {
        this.studentNo = studentNo;
        this.name = name;
    }

    public void setDepartment(String department) {
        this.department = department;
    }

    public void setAddress(String address) {
        this.address = address;
    }
}
```

- Lecture.java

```java
import java.util.Iterator;

public class Lecture<E> implements Iterable<E> {
    Student[] students;
    int index = 0;

    public Lecture(int size) {
        this.students = new Student[size];
    }

    public void add(Student student) {
        if (this.index >= students.length) {
            System.out.println("Class is full !");
        } else {
            this.students[this.index++] = student;
        }
    }

    @Override
    public Iterator iterator() {
        return new LectureIterator(this);
    }
}
```

- LectureIterator.java

```java
import java.util.Iterator;

public class LectureIterator implements Iterator {
    Lecture lecture;
    int index = 0;

    public LectureIterator(Lecture lecture) {
        this.lecture = lecture;
    }

    @Override
    public boolean hasNext() {
        if (this.index < lecture.students.length) {
            return true;
        } else {
            return false;
        }
    }

    @Override
    public Object next() {
        return this.lecture.students[this.index++];
    }
}
```

- Test.java

```java
public class Test {
    public static void main(String[] args) {
        Lecture lecture = new Lecture(5);
        lecture.add(new Student(1, "Celine"));
        lecture.add(new Student(2, "Vesper"));
        lecture.add(new Student(3, "Paloma"));
        lecture.add(new Student(4, "Clementine"));
        lecture.add(new Student(5, "Paloma"));

        LectureIterator iterator = (LectureIterator) lecture.iterator();

        while (iterator.hasNext()) {
            System.out.println(iterator.next());
        }
    }
}
```

---

### Reference
https://ko.wikipedia.org/wiki/SOLID_(객체_지향_설계)